#!/bin/bash
#
# Drupal Code Review
#
# A lightweight wrapper around phpcs.
#
# Installation (global):
# 1. Pull all dependecies:
# composer global require alexdesignworks/dcr
# 2. Link and copy required files (composer does not let to execute scripts):
# ~/.console/vendor/bin/dcr install && ~/.profile
#
# Installation (local):
# 1. Pull all dependecies:
# composer require alexdesignworks/dcr
# 2. Link and copy required files (composer does not let to execute scripts):
# vendor/bin/dcr install && ~/.profile
#
#
# Usage: dcr --help for usage.
#

# Array of known standards paths within vendor directory.
# Use 'dcr -i' to check which standards are available.
# Available tokens:
# %vendor% - vendor directory.
# %dcr% - dcr file location directory.
# %current% - the directory where the script was invoked in.
STANDARDS_PATHS=(
  %vendor%/drupal/coder/coder_sniffer
  %dcr%/php_codesniffer
  %current%/dcr_standards
)

# Configuation file name.
CONF=".dcr.yml"
# Configuation example file name.
EXAMPLE_CONF="example.dcr.yml"

# Current directory where dcr was invoked at.
CURRENT_DIR=$(pwd)
# dcr file location directory.
DCR_DIR="$(dirname -- "$(readlink -f -- "$0")")"

#
# Help message output.
#
function show_help() {
  echo "Drupal Code Review"
  echo
  echo "Installation (global):"
  echo "composer global require alexdesignworks/dcr"
  echo "dcr install && . ~/.profile"
  echo
  echo "Installation (local):"
  echo "composer require alexdesignworks/dcr"
  echo "dcr install && . ~/.profile"
  echo
  echo "Usage:"
  echo "dcr [--explain] [--brief] [*phpcs options] [<file or dir>]"
  echo
  echo "--explain       Show sniff codes oin all reports"
  echo "--brief         Show check progress only (no report). Usefull for CI."
  echo "*phpcs options  Any phpcs options ('phpcs --help' for options list)."
  echo "file or dir     Custom file or directory to check."
}

#
# Main entry point.
#
function main() {
  custom_options=""
  passthrough_options=""
  passthrough_targets=""

  for i in "$@"
  do
    case $i in
      --help)
      show_help
      return
      ;;
      install)
      install
      return
      ;;
      --explain)
      custom_options="${custom_options} -s"
      shift # past argument with no value
      ;;
      --brief)
      custom_options="${custom_options} -p --report-file=/dev/null"
      shift # past argument with no value
      ;;
      *)
      # Passthrough all unknown options.
      if [ "${i:0:1}" == "-" ] || [ "${i:0:2}" == "--" ]; then
        passthrough_options="${passthrough_options} ${i}"
      else
        passthrough_targets="${passthrough_targets} ${i}"
      fi
      shift
      ;;
    esac
  done

  # Read config from the file.
  conf_file=$CURRENT_DIR/$CONF
  # Error if no pass-through targets provided and config does not exist.`
  if [ ! -f $conf_file ] && [ "$passthrough_targets" == "" ] ; then
    echo "Unable to open DCR config file $conf_file. Please copy $DCR_DIR/$EXAMPLE_CONF to $conf_file."
    return 1
  fi

  # But try to include config for pass-through targets to use config from file.
  if [ -f $conf_file ] ; then
    eval $(parse_yaml $conf_file "conf_")
  fi

  # Validate and set parameters.
  if [ ${conf_extensions+x} ] ; then
    custom_options="--extensions=$conf_extensions $custom_options"
  fi

  if [ ${conf_standards+x} ] ; then
    custom_options="--standard=$conf_standards $custom_options"
  fi

  # Re-write targets if custom ones where passed to this script.
  custom_targets=""
  if [ "$passthrough_targets" == "" ] ; then
    # Check that targets were provided in cofig.
    if [ ${conf_targets+x} ] ; then
      custom_targets=$conf_targets
    elif [ ! ${passthrough_options+x} ] && [ ! ${custom_options+x} ] ; then
      echo "No targets were provided"
      return 1
    fi
  else
    custom_targets=$passthrough_targets
  fi

  # Use custom parameters from config.
  if [ ${conf_parameters+x} ] ; then
    custom_options="${custom_options} ${conf_parameters}"
  fi

  # Pass-through options always override any default and custom options.
  phpcs $custom_options $passthrough_options $custom_targets
  return_code=$?

  # Output success message, but only if it was set in config and this is not
  # a non-targeted run.
  if [ ${return_code} -eq 0 ] && [ ${conf_success+x} ] && [[ ! "${passthrough_options}" =~ "-i" ]] ; then
    echo
    cecho green "${conf_success}"
  fi

  # Output fail message, but only if it was set in config and this is not
  # a non-targeted run.
  if [ ${return_code} -eq 1 ] && [ ${conf_fail+x} ] && [[ ! "${passthrough_options}" =~ "-i" ]] ; then
    echo
    cecho red "${conf_fail}"
  fi

  return $return_code
}

#
# Additional installation steps.
#
function install() {
  # Check if DCR ran as dependency (installed into vendor dir) or as an app
  # by itself (for dcr development).
  if [[ "$DCR_DIR" =~ "vendor" ]]; then
    root_dir="$(dirname $(dirname $(dirname $DCR_DIR)))"
  else
    root_dir="$DCR_DIR"
  fi
  vendor_dir=${root_dir}/vendor

  # Get bin directory location from composer config.
  bin_dir=${root_dir}/$(composer config bin-dir)

  # Additnially, symlink dcr into vendor bin.
  if [ ! -L "${bin_dir}/dcr" ] ; then
    ln -s $DCR_DIR/dcr ${bin_dir}/dcr
    ln -s $DCR_DIR/dcr $HOME/bin/dcr
    echo "Symlinked dcr into ${bin_dir}"
  fi

  if /bin/cat ~/.profile | /bin/grep -ohq "PATH=$bin_dir:\$PATH\$"; then
    echo "DCR bin directory $bin_dir is already in PATH";
  else
    echo "PATH=$bin_dir:\$PATH" >> $HOME/.profile;
    . $HOME/.profile
    echo "Added DCR bin directory $bin_dir to PATH";
  fi

  # Add App standard directory to current dir to allow ruleset customisations.
  if [ ! -d "${CURRENT_DIR}/dcr_standards" ] ; then
    cp -r ${DCR_DIR}/dcr_standards ${CURRENT_DIR}
    echo "Copied dcr_standards directory to ${CURRENT_DIR}"
  else
    echo "dcr_standards directory already exists at ${CURRENT_DIR}"
  fi

  # Add code sniffer install path to phpcs config to allow proper stadnards
  # path resolution. This also handles paths for global and local installation.
  phpcs=$(which phpcs)
  if [[ "$phpcs" == "$bin_dir/phpcs" ]]; then
    installed_paths=""

    # Traverse all known sniffs locations and check for their existance before
    # setting.
    count=0
    while [ "x${STANDARDS_PATHS[count]}" != "x" ]
    do
       # Replace path tokens.
       standard_path=${STANDARDS_PATHS[count]}
       standard_path=$(echo ${standard_path} | sed -e "s?%vendor%?${vendor_dir}?g")
       standard_path=$(echo ${standard_path} | sed -e "s?%dcr%?${DCR_DIR}?g")
       standard_path=$(echo ${standard_path} | sed -e "s?%current%?${CURRENT_DIR}?g")

       if [ -d $standard_path ] ; then
        installed_paths=${installed_paths},${standard_path}
       fi
       count=$(( $count + 1 ))
    done

    if [ "${installed_paths}" != "" ] ; then
      # Remove leading comma.
      installed_paths=${installed_paths:1}
      phpcs --config-set installed_paths ${installed_paths}
      echo "Set installed_path to ${installed_paths}."
    else
      echo "No valid standards' paths provided."
    fi
  else
    echo "Incorrect phpcs is in use. Make sure that phpcs is available in this session."
    return 1
  fi

  # Copy config file.
  conf_file=$CURRENT_DIR/$CONF
  if [ -f $conf_file ] ; then
    echo "Skipping copying of config file - file $conf_file exists."
  else
    cp $DCR_DIR/$EXAMPLE_CONF $conf_file
    echo "Copied example config file $DCR_DIR/$EXAMPLE_CONF to $conf_file."
  fi

  echo
  echo "Please run . ~/.profile to make dcr available in current session"
}

#
# Simple key/value YAML parser.
#
parse_yaml() {
   local prefix=$2
   local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
   sed -ne "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $1 |
   awk -F$fs '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
         vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
         printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, $2, $3);
      }
   }'
}

#
# Colored echo.
#
cecho() {
  local code="\033["
  case "$1" in
    black  | bk) color="${code}0;30m";;
    red    |  r) color="${code}1;31m";;
    green  |  g) color="${code}1;32m";;
    yellow |  y) color="${code}1;33m";;
    blue   |  b) color="${code}1;34m";;
    purple |  p) color="${code}1;35m";;
    cyan   |  c) color="${code}1;36m";;
    gray   | gr) color="${code}0;37m";;
    *) local text="$1"
  esac
  [ -z "$text" ] && local text="$color$2${code}0m"
  echo -e "$text"
}

main "$@"
