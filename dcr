#!/bin/bash
#
# Drupal Code Review
#
# A lightweight wrapper around phpcs.
#
# Installation (global):
# 1. Pull all dependencies:
# composer global require alexdesignworks/dcr
# 2. Link and copy required files (composer does not let to execute scripts):
# ~/.console/vendor/bin/dcr install && ~/.profile
#
# Installation (local):
# 1. Pull all dependencies:
# composer require alexdesignworks/dcr
# 2. Link and copy required files (composer does not let to execute scripts):
# source vendor/bin/dcr install
#
# Usage: dcr --help for usage.
#
#
# .dcr.yml file can be stored in the root of your project (same level with
# `vendor` dir) or in it's parent directory.
#
# dcr must be invoked from project root or one of it's sub-directories.
#

# Array of known standards paths within vendor directory.
# Use 'dcr -i' to check which standards are available.
# Available tokens:
# %vendor% - vendor directory.
# %dcr% - dcr file location directory.
# %current% - the directory where the script was invoked in.
STANDARDS_PATHS=(
  %vendor%/drupal/coder/coder_sniffer
  %dcr%/php_codesniffer
  %current%/dcr_standards
)

# Configuration file name.
CONF=".dcr.yml"
# Configuration example file name.
EXAMPLE_CONF="example.dcr.yml"

# .jscsrc file name.
JSCSRC=".jscsrc"
# .jscsrc example file name.
EXAMPLE_JSCSRC=".jscsrc.drupal"

# Current directory where dcr was invoked at.
CURRENT_DIR=$(pwd)
# dcr file location directory.
DCR_DIR="$(dirname -- "$(readlink -f -- "$0")")"

#
# Help message output.
#
function show_help() {
  echo "Drupal Code Review"
  echo
  echo "Installation (global):"
  echo "composer global require alexdesignworks/dcr"
  echo "dcr install && . ~/.profile"
  echo
  echo "Installation (local):"
  echo "composer require alexdesignworks/dcr"
  echo "dcr install && . ~/.profile"
  echo
  echo "Lint:"
  echo "dcr [--explain] [--brief] [*phpcs options] [<file or dir>]"
  echo
  echo "explain,        Show sniff codes in all reports"
  echo "--explain"
  echo "--brief         Show check progress only (no report). Useful for CI."
  echo "*phpcs options  Any phpcs options ('phpcs --help' for options list)."
  echo "file or dir     Custom file or directory to check."
  echo
  echo "Fix:"
  echo "dcr fix [*phpcbf options] [<file or dir>]"
  echo
  echo "fix             Fix all warnings and errors"
  echo "*phpcbf options Any phpcbf options ('phpcbf --help' for options list)."
  echo "file or dir     Custom file or directory to check."
}

#
# Main entry point.
#
function main() {
  custom_options=""
  passthrough_options=""
  passthrough_targets=""
  binary="phpcs"

  for i in "$@"
  do
    case $i in
      --help)
      show_help
      return
      ;;
      install)
      install
      return
      ;;
      fix)
      binary="phpcbf"
      custom_options="${custom_options} --no-patch"
      shift
      ;;
      --explain|explain)
      custom_options="${custom_options} -s"
      shift
      ;;
      --brief)
      custom_options="${custom_options} -p --report-file=/dev/null"
      shift
      ;;
      *)
      # Passthrough all unknown options.
      if [ "${i:0:1}" == "-" ] || [ "${i:0:2}" == "--" ]; then
        passthrough_options="${passthrough_options} ${i}"
      else
        passthrough_targets="${passthrough_targets} ${i}"
      fi
      shift
      ;;
    esac
  done

  root_dir=$(get_root_dir)
  # Add a guard for running from root dir or one of its sub-dirs to make sure
  # that all paths are properly resolved.
  if [[ ! "$CURRENT_DIR" =~ "${root_dir}" ]] ; then
    echo "dcr has to be run from project dir (${root_dir}) or one of it's sub-directories"
    return 1
  fi

  # Read config from the file. We allow file location in project root dir (the
  # dir where `vendor` dir resides) or one dir above.
  conf_file=$(get_conf_file)

  # Error if config does not exist.
  if [ "$conf_file" == "" ] ; then
    echo "Unable to open DCR config file. Please copy $DCR_DIR/$EXAMPLE_CONF to project root."
    return 1
  fi

  # But try to include config for pass-through targets to use config from file.
  if [ -f $conf_file ] ; then
    eval $(parse_yaml $conf_file "conf_")
  fi

  # Validate and set parameters.
  if [ ${conf_extensions+x} ] ; then
    custom_options="--extensions=$conf_extensions $custom_options"
  fi

  if [ ${conf_standards+x} ] ; then
    custom_options="--standard=$conf_standards $custom_options"
  fi

  # Re-write targets if custom ones where passed to this script.
  custom_targets=""
  if [ "$passthrough_targets" != "" ] ; then
    # Targets passed to this script.
    custom_targets=$passthrough_targets
  else
    # Check that targets were provided in config.
    if [ ${conf_targets+x} ] && [ "$conf_targets" != "" ] ; then
      custom_targets=$conf_targets
    elif [ "${passthrough_options}" == "" ] ; then
      # No options were passed and no options were read from config.
      echo "No targets were provided"
      return 1
    fi
  fi

  # Use custom parameters from config.
  if [ ${conf_parameters+x} ] ; then
    custom_options="${custom_options} ${conf_parameters}"
  fi

  # Pass-through options always override any default and custom options.
  root_dir=$(get_root_dir)
  cd $root_dir
  $binary $custom_options $passthrough_options $custom_targets
  return_code=$?
  cd $CURRENT_DIR

  if [ "$binary" == "phpcs" ] ; then
    # Output success message, but only if it was set in config and this is not
    # a non-targeted run.
    if [ ${return_code} -eq 0 ] && [ ${conf_success+x} ] && [[ ! "${passthrough_options}" =~ "-i" ]] ; then
      echo
      cecho green "${conf_success}"
    fi

    # Output fail message, but only if it was set in config and this is not
    # a non-targeted run.
    if [ ${return_code} -eq 1 ] && [ ${conf_fail+x} ] && [[ ! "${passthrough_options}" =~ "-i" ]] ; then
      echo
      cecho red "${conf_fail}"
    fi
  fi

  return $return_code
}

#
# Additional installation steps.
#
function install() {
  root_dir=$(get_root_dir)
  vendor_dir=${root_dir}/vendor

  # Get bin directory location from composer config.
  bin_dir=${root_dir}/$(composer config bin-dir)

  # Additionally, symlink dcr into vendor bin.
  if [ ! -L "${bin_dir}/dcr" ] ; then
    ln -s $DCR_DIR/dcr ${bin_dir}/dcr
    echo "Symlinked dcr into ${bin_dir}"
  fi

  # Add "vendor/bin" into PATH, if it is not there.
  if /bin/echo $PATH | /bin/grep -ohq "$bin_dir"; then
    echo "DCR bin directory $bin_dir is already in PATH"
  else
    path_file=$HOME/.profile
    if /bin/cat $path_file | /bin/grep -ohq "PATH=$bin_dir:\$PATH\$"; then
      echo "DCR bin directory $bin_dir is already in PATH";
    else
      echo "PATH=$bin_dir:\$PATH" >> $path_file;
    fi

    export PATH=$bin_dir:$PATH

    if /bin/echo $PATH | /bin/grep -ohq "$bin_dir"; then
      echo "Added DCR bin directory $bin_dir to current session PATH";
    else
      echo "ERROR: Unable to add DCR bin directory $bin_dir to PATH";
      return 1
    fi
  fi

  # Add App standard directory to current dir to allow ruleset customisations.
  if [ ! -d "${CURRENT_DIR}/dcr_standards" ] ; then
    cp -r ${DCR_DIR}/dcr_standards ${CURRENT_DIR}
    echo "Copied dcr_standards directory to ${CURRENT_DIR}"
  else
    echo "dcr_standards directory already exists at ${CURRENT_DIR}"
  fi

  # Add code sniffer install path to phpcs config to allow proper standards
  # path resolution. This also handles paths for global and local installation.
  phpcs=$(which phpcs)
  if [[ "$phpcs" == "$bin_dir/phpcs" ]]; then
    installed_paths=""

    # Traverse all known sniffs locations and check for their existence before
    # setting.
    count=0
    while [ "x${STANDARDS_PATHS[count]}" != "x" ]
    do
       # Replace path tokens.
       standard_path=${STANDARDS_PATHS[count]}
       standard_path=$(echo ${standard_path} | sed -e "s?%vendor%?${vendor_dir}?g")
       standard_path=$(echo ${standard_path} | sed -e "s?%dcr%?${DCR_DIR}?g")
       standard_path=$(echo ${standard_path} | sed -e "s?%current%?${CURRENT_DIR}?g")

       if [ -d $standard_path ] ; then
        installed_paths=${installed_paths},${standard_path}
       fi
       count=$(( $count + 1 ))
    done

    if [ "${installed_paths}" != "" ] ; then
      # Remove leading comma.
      installed_paths=${installed_paths:1}
      phpcs --config-set installed_paths ${installed_paths}
      phpcbf --config-set installed_paths ${installed_paths}
      echo "Set installed_path to ${installed_paths}."
      # Set JSCS path.
      phpcs --config-set jscs_path $(npm bin)
    else
      echo "No valid standards' paths provided."
    fi
  else
    echo "Incorrect phpcs is in use. Make sure that phpcs is available in this session."
    return 1
  fi

  # Copy config file.
  conf_file=$CURRENT_DIR/$CONF
  if [ -f $conf_file ] ; then
    echo "Skipping copying of config file - file $conf_file exists."
  else
    cp $DCR_DIR/$EXAMPLE_CONF $conf_file
    echo "Copied example config file $DCR_DIR/$EXAMPLE_CONF to $conf_file."
  fi

  # Install JSCS.
  npm install jscs

  # Copy .jscsrc.drupal file.
  jscsrc_file=$CURRENT_DIR/$JSCSRC
  if [ -f $jscsrc_file ] ; then
    echo "Skipping copying of .jscsrc file - file $jscsrc_file exists."
  else
    cp $DCR_DIR/$EXAMPLE_JSCSRC $jscsrc_file
    echo "Copied example .jscsrc file $DCR_DIR/$EXAMPLE_JSCSRC to $jscsrc_file."
  fi
}

#
# Get root dir (the dir where `vendor` dir resides).
#
get_root_dir() {
  # Check if DCR ran as dependency (installed into vendor dir) or as an app
  # by itself (for dcr development).
  if [[ "$DCR_DIR" =~ "vendor" ]]; then
    root_dir="$(dirname $(dirname $(dirname $DCR_DIR)))"
  else
    root_dir="$DCR_DIR"
  fi

  echo $root_dir
}

#
# Get conf file location.
#
get_conf_file() {
  root_dir=$(get_root_dir)
  conf_files=(
    # Current dir.
    $CURRENT_DIR/$CONF
    # Dir above current.
    $(dirname $CURRENT_DIR)/$CONF
    # Root dir.
    $root_dir/$CONF
    # Dir above root.
    $(dirname $root_dir)/$CONF
  )
  # Traverse all known config locations.
  matched_conf_file=""
  count=0
  while [ "x${conf_files[count]}" != "x" ]
  do
    if [ -f "${conf_files[count]}" ] ; then
      matched_conf_file=${conf_files[count]}
      break
    fi
    count=$(( $count + 1 ))
  done

  echo $matched_conf_file
}

#
# Simple key/value YAML parser.
#
parse_yaml() {
   local prefix=$2
   local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
   sed -ne "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $1 |
   awk -F$fs '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
         vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
         printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, $2, $3);
      }
   }'
}

#
# Colored echo.
#
cecho() {
  local code="\033["
  case "$1" in
    black  | bk) color="${code}0;30m";;
    red    |  r) color="${code}1;31m";;
    green  |  g) color="${code}1;32m";;
    yellow |  y) color="${code}1;33m";;
    blue   |  b) color="${code}1;34m";;
    purple |  p) color="${code}1;35m";;
    cyan   |  c) color="${code}1;36m";;
    gray   | gr) color="${code}0;37m";;
    *) local text="$1"
  esac
  [ -z "$text" ] && local text="$color$2${code}0m"
  echo -e "$text"
}

main "$@"
